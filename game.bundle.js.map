{"version":3,"sources":["webpack://snake-game/./src/Frame.ts","webpack://snake-game/./src/utils.ts","webpack://snake-game/./src/Snake.ts","webpack://snake-game/./src/Game.ts","webpack://snake-game/./src/index.ts"],"names":["cellPositionHash","cell","join","ctx","canvasWidth","canvasHeight","frameWidth","frameHeight","this","create","Frame","instance","getXCoordinate","x","unit","OFFSET_X","getYCoordinate","y","OFFSET_Y","draw","width","height","fillStyle","fillRect","minPadding","MAX_X","Math","floor","MAX_Y","strokeStyle","strokeRect","makeBorderWall","drawBrick","_x","_y","occupiedCellMap","MIN_X","MIN_Y","undefined","getRandomInt","min","max","ceil","random","Direction","eatAudio","Audio","preload","outAudio","initialSnakeBody","callbacks","direction","EAST","food","canTurn","body","Snake","reset","forEach","drawCell","clear","options","cellHash","size","foodX","foodY","makeFood","addCell","unshift","getNextHead","headX","headY","WEST","NORTH","SOUTH","eatFoodIfAvailable","play","ateFood","checkIfDead","kill","index","killed","move","isDead","tailCell","pop","nextCell","turn","side","newDirection","left","right","up","down","GameLevel","canvas","setAttribute","toString","frame","snake","score","level","ONE","timer","shouldReset","incrementScore","onScoreUpdate","levelUp","handleGameOver","handleKeyPress","e","defaultPrevented","code","togglePause","preventDefault","document","querySelector","Error","getContext","window","addEventListener","init","Game","delay","console","log","setInterval","pause","onGameOver","onPlay","clearInterval","onPause","HIGH_SCORE","updateScoreView","scoreEle","getElementById","innerHTML","updateHighScoreView","highScore","highScoreEle","innerWidth","documentElement","clientWidth","innerHeight","clientHeight","localStorage","getItem","game","setItem","hidden","main"],"mappings":"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","file":"game.bundle.js","sourcesContent":["export type CellPosition = [x: number, y: number];\nexport const cellPositionHash = (cell: CellPosition) => cell.join();\n\nexport default class Frame {\n  public static readonly unit = 20;\n\n  public static OFFSET_X = 0;\n  public static OFFSET_Y = 0;\n\n  public static MIN_X = 0;\n  public static MAX_X = 0;\n\n  public static MIN_Y = 0;\n  public static MAX_Y = 0;\n\n  public static occupiedCellMap: { [cellPositionHash: string]: boolean } = {};\n\n  private static instance: Frame | undefined = undefined;\n\n  public static create(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number) {\n    if (Frame.instance) return Frame.instance;\n    return new Frame(ctx, canvasWidth, canvasHeight);\n  }\n\n  public static getXCoordinate(x: number) {\n    return x * Frame.unit + Frame.OFFSET_X;\n  }\n\n  public static getYCoordinate(y: number) {\n    return y * Frame.unit + Frame.OFFSET_Y;\n  }\n\n  private ctx: CanvasRenderingContext2D;\n\n  /** canvas width */\n  private canvasWidth: number;\n  /** canvas height */\n  private canvasHeight: number;\n\n  /** frame painting width */\n  public frameWidth = 0;\n  /** frame painting height */\n  public frameHeight = 0;\n\n  constructor(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number) {\n    this.ctx = ctx;\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n  }\n\n  public draw() {\n    const width = this.canvasWidth;\n    const height = this.canvasHeight;\n\n    // draw main reactangle\n    this.ctx.fillStyle = '#000';\n    this.ctx.fillRect(0, 0, width, height);\n\n    const minPadding = Frame.unit;\n\n    // frame width should be integral multiple of Frame.unit\n    Frame.MAX_X = Math.floor((width - 2 * minPadding) / Frame.unit) - 1; // zero based index\n    this.frameWidth = (Frame.MAX_X + 1) * Frame.unit;\n\n    // frame height should be integral multiple of Frame.unit\n    Frame.MAX_Y = Math.floor((height - 2 * minPadding) / Frame.unit) - 1; // zero based index\n    this.frameHeight = (Frame.MAX_Y + 1) * Frame.unit;\n\n    Frame.OFFSET_X = (width - this.frameWidth) / 2;\n    Frame.OFFSET_Y = (width - this.frameWidth) / 2;\n\n    // borders\n    this.ctx.strokeStyle = '#fff';\n    this.ctx.strokeRect(Frame.OFFSET_X, Frame.OFFSET_Y, this.frameWidth, this.frameHeight);\n\n    this.makeBorderWall();\n  }\n\n  private drawBrick([_x, _y]: CellPosition) {\n    const x = Frame.getXCoordinate(_x);\n    const y = Frame.getYCoordinate(_y);\n\n    this.ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';\n    this.ctx.fillRect(x, y, Frame.unit, Frame.unit);\n    this.ctx.strokeStyle = '#fff';\n    this.ctx.strokeRect(x, y, Frame.unit, Frame.unit);\n\n    Frame.occupiedCellMap[cellPositionHash([_x, _y])] = true;\n  }\n\n  private makeBorderWall() {\n    for (let x = 0; x <= Frame.MAX_X; x++) {\n      this.drawBrick([x, 0]); // top wall\n      this.drawBrick([x, Frame.MAX_Y]); // bottom wall\n    }\n\n    for (let y = 1; y < Frame.MAX_Y; y++) {\n      this.drawBrick([0, y]); // left wall\n      this.drawBrick([Frame.MAX_X, y]); // right wall\n    }\n  }\n}\n","export function windowBounds() {\n  const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n  const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n  return { width, height };\n}\n\n/**\n * Generates a random number\n * @param min minimum value (inclusive)\n * @param max maximum value (exclusive)\n * @see https://stackoverflow.com/a/1527820/9709887\n */\nexport function getRandomNumber(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Generates random integer. The value is no lower than\n * min (or the next integer greater than min if min isn't\n * an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * @param min minimum value (inclusive)\n * @param max maximum value (exclusive)\n * @see https://stackoverflow.com/a/1527820/9709887\n */\nexport function getRandomInt(min: number, max: number) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","import Frame, { CellPosition, cellPositionHash } from './Frame';\nimport { getRandomInt } from './utils';\n\ninterface CellOptions {\n  fillStyle?: string;\n  clear?: boolean;\n}\n\nenum Direction {\n  NORTH,\n  EAST,\n  SOUTH,\n  WEST,\n}\n\nconst eatAudio = new Audio(`${process.env.PUBLIC_PATH}assets/eat.wav`);\neatAudio.preload = 'auto';\n\nconst outAudio = new Audio(`${process.env.PUBLIC_PATH}assets/out.wav`);\noutAudio.preload = 'auto';\n\nconst initialSnakeBody: CellPosition[] = [\n  [4, 1], // head\n  [3, 1],\n  [2, 1],\n  [1, 1], // tail\n];\n\ninterface Callbacks {\n  ateFood: () => void;\n  killed: () => void;\n}\n\nexport default class Snake {\n  public static instance: Snake | undefined;\n\n  public static create(ctx: CanvasRenderingContext2D, callbacks: Callbacks) {\n    if (Snake.instance) return Snake.instance;\n    return new Snake(ctx, callbacks);\n  }\n\n  private ctx: CanvasRenderingContext2D;\n\n  private direction: Direction = Direction.EAST;\n\n  /** x, y co-ordinate index */\n  public food: CellPosition = [-1, -1];\n\n  /** used to enable/disable turning */\n  private canTurn = true;\n\n  private body: CellPosition[] = [...initialSnakeBody];\n\n  private callbacks: Callbacks;\n\n  constructor(ctx: CanvasRenderingContext2D, callbacks: Callbacks) {\n    this.ctx = ctx;\n    this.callbacks = callbacks;\n  }\n\n  public reset() {\n    // remove current snake body cells from Frame\n    this.body.forEach((cell) => {\n      this.drawCell(cell, { clear: true });\n    });\n\n    // remove food\n    this.drawCell(this.food, { clear: true });\n\n    this.canTurn = true;\n    this.direction = Direction.EAST;\n\n    this.food = [-1, -1];\n    this.body = [...initialSnakeBody];\n\n    // repaint\n    this.draw();\n  }\n\n  public drawCell([_x, _y]: CellPosition, options?: CellOptions) {\n    const cellHash = cellPositionHash([_x, _y]);\n\n    const x = Frame.getXCoordinate(_x) + 2;\n    const y = Frame.getXCoordinate(_y) + 2;\n    const size = Frame.unit - 4;\n\n    if (options?.clear) {\n      // to clear a rectangle fill it with background color\n      this.ctx.fillStyle = '#000';\n      this.ctx.fillRect(x, y, size, size);\n      this.ctx.strokeStyle = '#000';\n      this.ctx.strokeRect(x, y, size, size);\n\n      Frame.occupiedCellMap[cellHash] = false;\n      return;\n    }\n\n    // outer rectangle\n    this.ctx.fillStyle = options?.fillStyle || 'rgba(0, 255, 0, 0.8)';\n    this.ctx.fillRect(x, y, size, size);\n\n    Frame.occupiedCellMap[cellHash] = true;\n  }\n\n  public draw() {\n    const [foodX, foodY] = this.food;\n\n    if (foodX === -1 && foodY === -1) {\n      // create new food\n      this.makeFood();\n    } else {\n      // repaint food at same position\n      this.makeFood(this.food);\n    }\n\n    this.body.forEach((cell) => {\n      this.drawCell(cell);\n    });\n  }\n\n  private addCell(cell: CellPosition) {\n    this.body.unshift(cell);\n    this.drawCell(cell);\n  }\n\n  private makeFood(cell?: CellPosition) {\n    if (!cell) {\n      /**\n       * loop to ensure that new food position does not\n       * coincide with any walls of snake's body cell position\n       */\n      do {\n        cell = [\n          getRandomInt(Frame.MIN_X + 1, Frame.MAX_X - 1), // x\n          getRandomInt(Frame.MIN_Y + 1, Frame.MAX_Y - 1), // y\n        ];\n        this.food = cell;\n      } while (Frame.occupiedCellMap[cellPositionHash(cell)]);\n    }\n\n    this.drawCell(this.food, {\n      fillStyle: 'rgba(255, 255, 0, 0.8)',\n    });\n  }\n\n  private getNextHead(): CellPosition {\n    const [headX, headY] = this.body[0];\n    switch (this.direction) {\n      case Direction.EAST:\n        return [headX + 1, headY];\n      case Direction.WEST:\n        return [headX - 1, headY];\n      case Direction.NORTH:\n        return [headX, headY - 1];\n      case Direction.SOUTH:\n        return [headX, headY + 1];\n      default:\n        return [headX, headY];\n    }\n  }\n\n  /**\n   * Eat food if available,\n   * also create another food if ate food.\n   */\n  private eatFoodIfAvailable() {\n    const [foodX, foodY] = this.food;\n    const [headX, headY] = this.body[0];\n\n    if (headX === foodX && headY === foodY) {\n      eatAudio.play();\n      this.addCell(this.getNextHead());\n      this.makeFood();\n      this.callbacks.ateFood();\n    }\n  }\n\n  private checkIfDead() {\n    const [foodX, foodY] = this.food;\n    const [headX, headY] = this.getNextHead();\n\n    if (\n      !(foodX === headX && foodY === headY) && // not food position\n      Frame.occupiedCellMap[cellPositionHash([headX, headY])]\n    ) {\n      // snake is self-hit of hit to a wall\n      this.kill();\n      return true;\n    }\n\n    return false;\n  }\n\n  private kill() {\n    outAudio.play();\n    this.body.forEach((cell, index) => {\n      this.drawCell(cell, { clear: true });\n      if (index === 0) {\n        // head\n        this.drawCell(cell, { fillStyle: 'rgba(255, 0, 0, 0.5)' });\n      } else {\n        this.drawCell(cell, { fillStyle: 'rgba(110, 110, 110, 0.8)' });\n      }\n    });\n    this.callbacks.killed();\n  }\n\n  public move() {\n    const isDead = this.checkIfDead();\n    if (isDead) return true;\n\n    this.eatFoodIfAvailable();\n\n    // clear tail cell\n    const tailCell = this.body.pop()!;\n    this.drawCell(tailCell, { clear: true });\n\n    const nextCell = this.getNextHead();\n\n    // make new head cell\n    this.addCell(nextCell);\n\n    // enable turning again\n    this.canTurn = true;\n    return isDead;\n  }\n\n  public turn(side: 'left' | 'right' | 'up' | 'down') {\n    if (!this.canTurn) return;\n\n    const turnMap = {\n      [Direction.NORTH]: {\n        left: Direction.WEST,\n        right: Direction.EAST,\n        up: Direction.NORTH, // no turning\n        down: Direction.NORTH, // no turning\n      },\n      [Direction.EAST]: {\n        up: Direction.NORTH,\n        down: Direction.SOUTH,\n        left: Direction.EAST, // no turning\n        right: Direction.EAST, // no turning\n      },\n      [Direction.SOUTH]: {\n        left: Direction.WEST,\n        right: Direction.EAST,\n        up: Direction.SOUTH, // no turning\n        down: Direction.SOUTH, // no turning\n      },\n      [Direction.WEST]: {\n        up: Direction.NORTH,\n        down: Direction.SOUTH,\n        left: Direction.WEST, // no turning\n        right: Direction.WEST, // no turning\n      },\n    };\n\n    const newDirection = turnMap[this.direction][side];\n\n    if (this.direction !== newDirection) {\n      this.direction = newDirection;\n      // disable turning until next move\n      this.canTurn = false;\n    }\n  }\n}\n","import Frame from './Frame';\nimport Snake from './Snake';\n\nenum GameLevel {\n  ONE = 1,\n  TWO,\n  THREE,\n  FOUR,\n}\n\ninterface GameOptions {\n  width: number;\n  height: number;\n  onScoreUpdate?: (score: number) => void;\n  onPlay?: (score: number) => void;\n  onPause?: () => void;\n  onGameOver?: () => void;\n}\n\nexport default class Game {\n  private static instance: Game | undefined;\n\n  public static init(options: GameOptions) {\n    if (Game.instance) return Game.instance;\n    return new Game(options);\n  }\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  private canvasWidth: number;\n  private canvasHeight: number;\n\n  private frame: Frame;\n  private snake: Snake;\n\n  private options: GameOptions;\n\n  constructor(options: GameOptions) {\n    const canvas = document.querySelector<HTMLCanvasElement>('#game-board');\n\n    if (!canvas) {\n      throw new Error('Game board canvas not found!');\n    }\n\n    const ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n      throw new Error('Unable to get 2d context!');\n    }\n\n    this.ctx = ctx;\n    this.canvas = canvas;\n    this.options = options;\n\n    this.canvasWidth = options.width;\n    this.canvasHeight = options.height;\n\n    this.frame = Frame.create(this.ctx, this.canvasWidth, this.canvasHeight);\n    this.snake = Snake.create(this.ctx, {\n      ateFood: this.incrementScore,\n      killed: this.handleGameOver,\n    });\n\n    this.draw();\n\n    window.addEventListener('resize', this.draw);\n    window.addEventListener('keydown', this.handleKeyPress, true);\n  }\n\n  public draw = () => {\n    this.canvas.setAttribute('width', this.canvasWidth.toString());\n    this.canvas.setAttribute('height', this.canvasHeight.toString());\n    this.frame.draw();\n    this.snake.draw();\n  };\n\n  private score = 40;\n  private level = GameLevel.ONE;\n  private timer: NodeJS.Timeout | undefined = undefined;\n\n  private shouldReset = false;\n\n  private reset() {\n    this.score = 40;\n    this.level = GameLevel.ONE;\n    this.snake.reset();\n    this.shouldReset = false;\n  }\n\n  public play() {\n    if (this.timer) return;\n\n    if (this.shouldReset) this.reset();\n\n    const delay = 250 - 50 * this.level;\n    console.log({ delay, level: this.level });\n    this.timer = setInterval(() => {\n      const isDead = this.snake.move();\n      if (isDead) {\n        this.pause();\n        this.options.onGameOver && this.options.onGameOver();\n      }\n    }, delay);\n\n    this.options.onPlay && this.options.onPlay(this.score);\n  }\n\n  public pause() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = undefined;\n      this.options.onPause && this.options.onPause();\n    }\n  }\n\n  private togglePause() {\n    if (this.timer) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n\n  public levelUp() {\n    if (this.level < 5) {\n      this.pause();\n      this.level++;\n      this.play();\n    }\n  }\n\n  public incrementScore = () => {\n    this.score += 10;\n    this.options.onScoreUpdate && this.options.onScoreUpdate(this.score);\n\n    if (this.score % 100 === 0) {\n      this.levelUp();\n    }\n  };\n\n  public handleGameOver = () => {\n    this.shouldReset = true;\n  };\n\n  public handleKeyPress = (e: KeyboardEvent) => {\n    if (e.defaultPrevented) {\n      return; // Do nothing if the event was already processed\n    }\n\n    switch (e.code) {\n      case 'ArrowRight':\n        this.snake.turn('right');\n        break;\n      case 'ArrowLeft':\n        this.snake.turn('left');\n        break;\n      case 'ArrowUp':\n        this.snake.turn('up');\n        break;\n      case 'ArrowDown':\n        this.snake.turn('down');\n        break;\n      case 'Space':\n        this.togglePause();\n        break;\n      default:\n        break;\n    }\n\n    // Cancel the default action to avoid it being handled twice\n    e.preventDefault();\n  };\n}\n","import Game from './Game';\nimport './styles.scss';\nimport { windowBounds } from './utils';\n\nconst HIGH_SCORE = 'sg_+sdlkfj234fsd1!@#$';\n\nfunction updateScoreView(score: number) {\n  const scoreEle = document.getElementById('score');\n  if (scoreEle) {\n    scoreEle.innerHTML = score.toString();\n  }\n}\n\nfunction updateHighScoreView(highScore: number | string) {\n  const highScoreEle = document.getElementById('highScore');\n  if (highScoreEle) {\n    highScoreEle.innerHTML = highScore.toString();\n  }\n}\n\nexport function main() {\n  const { width, height } = windowBounds();\n\n  let highScore = localStorage.getItem(HIGH_SCORE) || 40;\n\n  // initialize scoring views\n  updateHighScoreView(highScore);\n  updateScoreView(40);\n\n  const game = Game.init({\n    height,\n    width: width * 0.75,\n    onPlay: updateScoreView,\n    onScoreUpdate: (score) => {\n      if (score >= highScore) {\n        highScore = score;\n        localStorage.setItem(HIGH_SCORE, score.toString());\n        updateHighScoreView(highScore);\n      }\n      updateScoreView(score);\n    },\n  });\n\n  document.addEventListener('visibilitychange', () => {\n    if (document.hidden) {\n      game.pause();\n    }\n  });\n}\n\nmain();\n"],"sourceRoot":""}